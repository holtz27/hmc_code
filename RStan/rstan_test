data{
  int < lower = 0 > T;
  real y0;
  vector [ T ] y;
}
parameters{
  real mu;                                // mean log volatility
  real < lower = 0, upper = 1 > phiT;     // persistence of volatility
  real < lower = 0 > s2;
  vector [T] h_std;                       // std log volatility time t
  vector < lower = 0 > [T]  l;
  real b0;
  real < lower = 0, upper = 1 > b1T;
  real b2;
  real <lower = 0 > v;
}
transformed parameters{
  real < lower = -1, upper = 1 > phi;
  real < lower = -1, upper = 1 > b1;
  real < lower = 0 > sigma;
  vector [T] h;                         // now h ~ normal(0, sigma)
  vector [T] mu_t;
  vector [T] sd_t;
  
  phi = 2 * phiT - 1;
  b1 = 2 * b1T - 1;
  sigma = sqrt(s2);
  
  
  //--- Volatilitys:
  h = h_std * sigma;
  h[1] /= sqrt(1 - phi * phi);         // rescale h[1]
  h += mu;
  for (t in 2:T) {
    h[t] += phi * (h[t - 1] - mu);
  }
  
  //--- Means:
  mu_t[1] = b0 + y0 * b1 + exp( h[1] ) * b2;
  for(t in 2:T){
    mu_t[t] = b0 + y[t-1] * b1 + exp( h[t] ) * b2;
  }
  //--- Variances:
  for(t in 1:T){
    sd_t[t] = exp( h[t] / 2 ) / sqrt( l[t] );
  }
  
}
model{
  // --- prioris log - volatiliti
  mu ~ normal(0, 10);
  phiT ~ beta(20, 1.5);
  s2 ~ inv_gamma(2.5, 0.025);
  
  //--- prioris component means:
  b0 ~ normal(0, 10);
  b1T ~ beta(5, 1.5);
  b2 ~ normal(0, 10);
  
  //--- prioris component heavy-tailed:
  v ~ gamma(2, 2);
  for(t in 1:T){
    l[t] ~ gamma(0.5 * v, 0.5 * v);  
  }
  
  /*
  //--- Sampling volatilitys:
  //h_std ~ std_normal();
  h[1] ~ normal(mu, sigma / sqrt(1 - phi * phi));
  for (t in 2:T){
    h[t] ~ normal(mu + phi * ( h[t - 1] -  mu ), sigma);
  }
  */
  
  //--- Sampling observations:
  y ~ normal( mu_t, sd_t );
  /*
  y[1] ~ normal(b0 + y0 * b1 + exp( h[1] ) * b2,  exp( h[1]/2 ) );
  for(t in 2:T){
    y[t] ~ normal(b0 + y0 * b1 + exp( h[t] ) * b2,  exp( h[t]/2 ) );
  }
  */
}

#########################################################################################
library(rstan)
library(stringr)

options(mc.cores = parallel::detectCores())
path = 'Área de Trabalho/Mestrado/Projeto/Projeto II/Simulação/rstan/stan_model.stan'
model  = stan_model(path)

# Running stan code
T = length(y)
M  = 1e3
fit = sampling(model, 
               list(T = T, 
                    y = y,
                    y0 = 0),
               iter = M,
               chains = 4)

#------------------ Save outputs
#saveRDS(parameters, file = 'output_model_V')
#parameters = readRDS('output_model_V')

#------------------ Plots
parameters = extract(fit)
x = summary(fit)
Y = x$summary
#------------------ Tratando Y
Y = data.frame(Y, row.names = row.names(Y))
row.names(Y) = str_replace(row.names(Y), pattern = 'b0_', '.b0')
row.names(Y) = str_replace(row.names(Y), pattern = 'b1_', '.b1')
row.names(Y) = str_replace(row.names(Y), pattern = 'b2_', '.b2')
#------------------ Avaliando convergência
rows = c('mu', 'phi', 'sigma', 'b0', 'b1', 'b2', 'v')
cols = c('mean', 'sd', 'X2.5.', 'X97.5.', 'n_eff','Rhat')
data = Y[rows, cols]
data

# h
rhat_h = Y[str_detect(row.names(Y), pattern = '^h'),][, 'Rhat']
# l
rhat_l = Y[str_detect(row.names(Y), pattern = '^l'),][, 'Rhat']

par(mfrow=c(1,2))
plot(rhat_h, main = 'h')
abline(h=0.95)
abline(h=1.05)
plot(rhat_l, main = 'l')
abline(h=0.95)
abline(h=1.05)
par(mfrow=c(1,1))

# mu
mu = parameters$mu
par(mfrow=c(1,3))
plot(mu, type='l', main='', xlab='')
hist(mu, main = round(mean(mu), 3), xlab='', col = 'white', breaks = 40)
abline(v = mean(mu), col = 'blue', lwd=2, lty=2)
abline(v = Y['mu', ]['X2.5.'], col = 'red', lwd=2, lty=2)
abline(v = Y['mu', ]['X97.5.'], col = 'red', lwd=2, lty=2)
plot(acf(mu, lag.max = 100, plot = FALSE)[1:100])
par(mfrow=c(1,1))  

# phi
phi = parameters$phi
par(mfrow=c(1,3))
plot(phi, type='l', main='', xlab='')
hist(phi, main = round(mean(phi), 3), xlab='', col = 'white', breaks = 40)
abline(v = mean(phi), col = 'blue', lwd=2, lty=2)
abline(v = Y['phi', ]['X2.5.'], col = 'red', lwd=2, lty=2)
abline(v = Y['phi', ]['X97.5.'], col = 'red', lwd=2, lty=2)
plot(acf(phi, lag.max = 100, plot = FALSE)[1:100])
par(mfrow=c(1,1))

# sigma
s = parameters$sigma
par(mfrow=c(1,3))
plot(s, type='l', main='', xlab='')
hist(s, main = round(mean(s), 3), xlab='', col = 'white', breaks = 40)
abline(v = mean(s), col = 'blue', lwd=2, lty=2)
abline(v = Y['sigma', ]['X2.5.'], col = 'red', lwd=2, lty=2)
abline(v = Y['sigma', ]['X97.5.'], col = 'red', lwd=2, lty=2)
plot(acf(s, lag.max = 100, plot = FALSE)[1:100])
par(mfrow=c(1,1)) 

################################################################################
############### Análise numérica
theta = matrix( c( mu, phi, s ), ncol = 3 )
mcmcchain_theta = coda::as.mcmc( theta )
####### Geweke Statistic
# |G| > 1.96 evidencia não convergencia
CD_theta = coda::geweke.diag( mcmcchain_theta )
CD_theta
####### Fator de ineficiência (IF)
# IF = N / N_eff, onde N_eff = effective Sample Size
# Se IF >> 1, indica uma má mistura da cadeia gerada
N_eff_theta = coda::effectiveSize( mcmcchain_theta )
IF_theta = nrow(theta) / N_eff_theta
IF_theta
####### MCMC error
# MCerror = sd( Variavel ) / sqrt( N_eff )
mc_error_theta = round( apply( theta, MARGIN = 2, FUN = sd) / sqrt( N_eff_theta ), 5 )
mc_error_theta
################################################################################

# b0
b0 = parameters$b0
par(mfrow=c(1,3))
plot(b0, type='l', main='', xlab='')
hist(b0, main=round(mean(b0), 8), xlab='', col = 'white', breaks = 40)
abline(v = mean(b0), col = 'blue', lwd=2, lty=2)
abline(v = Y['b0', ]['X2.5.'], col = 'red', lwd=2, lty=2)
abline(v = Y['b0', ]['X97.5.'], col = 'red', lwd=2, lty=2)
plot(acf(b0, lag.max = 100, plot = FALSE)[1:100])
par(mfrow=c(1,1)) 

# b1
b1 = parameters$b1
par(mfrow=c(1,3))
plot(b1, type='l', main='', xlab='')
hist(b1, main=round(mean(b1), 8), xlab='', col = 'white', breaks = 40)
abline(v = mean(b1), col = 'blue', lwd=2, lty=2)
abline(v = Y['b1', ]['X2.5.'], col = 'red', lwd=2, lty=2)
abline(v = Y['b1', ]['X97.5.'], col = 'red', lwd=2, lty=2)
plot(acf(b1, lag.max = 100, plot = FALSE)[1:100])
par(mfrow=c(1,1)) 

# b2
b2 = parameters$b2
par(mfrow=c(1,3))
plot(b2, type='l', main='', xlab='')
hist(b2, main=round(mean(b2), 8), xlab='', col = 'white', breaks = 40)
abline(v = mean(b2), col = 'blue', lwd=2, lty=2)
abline(v = Y['b2', ]['X2.5.'], col = 'red', lwd=2, lty=2)
abline(v = Y['b2', ]['X97.5.'], col = 'red', lwd=2, lty=2)
plot(acf(b2, lag.max = 100, plot = FALSE)[1:100])
par(mfrow=c(1,1)) 
################################################################################
############### Análise numérica
b = matrix( c( b0, b1, b2 ), ncol = 3 )
mcmcchain_b = coda::as.mcmc( b )
####### Geweke Statistic
# |G| > 1.96 evidencia não convergencia
CD_b = coda::geweke.diag( mcmcchain_b )
CD_b
####### Fator de ineficiência (IF)
# IF = N / N_eff, onde N_eff = effective Sample Size
# Se IF >> 1, indica uma má mistura da cadeia gerada
N_eff_b = coda::effectiveSize( mcmcchain_b )
IF_b = nrow(b) / N_eff_b
IF_b
####### MCMC error
# MCerror = sd( Variavel ) / sqrt( N_eff )
mc_error_b = round( apply( b, MARGIN = 2, FUN = sd) / sqrt( N_eff_b ), 5 )
mc_error_b
################################################################################

# v
v = parameters$v
par(mfrow=c(1,3))
plot(v, type='l', main='', xlab='')
hist(v, main=round(mean(v), 8), xlab='', col = 'white', breaks = 40)
abline(v = mean(v), col = 'blue', lwd=2, lty=2)
abline(v = Y['v', ]['X2.5.'], col = 'red', lwd=2, lty=2)
abline(v = Y['v', ]['X97.5.'], col = 'red', lwd=2, lty=2)
plot(acf(v, lag.max = 100, plot = FALSE)[1:100])
par(mfrow=c(1,1)) 
################################################################################
############### Análise numérica
#b = matrix( c( b0, b1, b2 ), ncol = 3 )
mcmcchain_v = coda::as.mcmc( matrix(v, ncol = 1) )
####### Geweke Statistic
# |G| > 1.96 evidencia não convergencia
CD_v = coda::geweke.diag( mcmcchain_v )
CD_v
####### Fator de ineficiência (IF)
# IF = N / N_eff, onde N_eff = effective Sample Size
# Se IF >> 1, indica uma má mistura da cadeia gerada
N_eff_v = coda::effectiveSize( mcmcchain_v )
IF_v = nrow(v) / N_eff_v
IF_v
####### MCMC error
# MCerror = sd( Variavel ) / sqrt( N_eff )
mc_error_v = round( sd( v ) / sqrt( N_eff_v ), 5 )
mc_error_v
################################################################################

# h
chain_h = parameters$h
h_hat = apply(chain_h, 2, mean)
lim_inf = apply(chain_h, 2, quantile, probs=c(.025, .975))[1,]
lim_sup = apply(chain_h, 2, quantile, probs=c(.025, .975))[2,]
df = data.frame(x=1:T, ver = h, est = h_hat, 
                lim_inf = lim_inf, lim_sup = lim_sup)
g = ggplot(df) 
g = g + geom_ribbon(aes(x, ymin = lim_inf, ymax = lim_sup), fill="gray80")
g = g + geom_line(aes(x=x, y = ver), color ='red')
g = g + geom_line(aes(x=x, y=est))
#g = g + geom_line(aes(x=x, y = lim_inf), linetype = 'dashed')
#g = g + geom_line(aes(x=x, y = lim_sup), linetype = 'dashed')
g
############### Análise numérica
mcmcchain_h = coda::as.mcmc( chain_h ) 
####### Geweke Statistic
# |G| > 1.96 evidencia não convergencia
CD_h = coda::geweke.diag( mcmcchain_h )
plot( CD_h$z )
abline(h = -1.96)
abline(h = 1.96)
####### Fator de ineficiência (IF)
# IF = N / N_eff, onde N_eff = effective Sample Size
# Se IF >> 1, indica uma má mistura da cadeia gerada
N_eff_h = coda::effectiveSize( mcmcchain_h )
IF_h = nrow(chain_h) / N_eff_h
plot( IF_h )
abline(h = 1)
####### MCMC error
# MCerror = sd( Variavel ) / sqrt( N_eff )
mc_error_h = round( apply( chain_h, MARGIN = 2, FUN = sd) / sqrt( N_eff_h ), 5 )
plot( mc_error_h )

####################################################################################
# l
burned_l_sim = parameters$l
l_hat = apply(burned_l_sim, 2, mean)
lim_inf = apply(burned_l_sim, 2, quantile, probs=c(.025, .975))[1,]
lim_sup = apply(burned_l_sim, 2, quantile, probs=c(.025, .975))[2,]
df.0 = data.frame(x=1:T, ver = l, est = l_hat, 
                  lim_inf = lim_inf, lim_sup = lim_sup)
g0 = ggplot(df.0) 
g0 = g0 + geom_line(aes(x=x, y = est))
g0 = g0 + geom_line(aes(x=x, y = ver), color ='red')
g0 = g0 + geom_line(aes(x=x, y = lim_inf), linetype = 'dashed')
g0 = g0 + geom_line(aes(x=x, y = lim_sup), linetype = 'dashed')
g0
############### Análise numérica
mcmcchain_l = coda::as.mcmc( burned_l_sim ) 
####### Geweke Statistic
# |G| > 1.96 evidencia não convergencia
CD_l = coda::geweke.diag( mcmcchain_l )
plot( CD_l$z )
abline(h = -1.96)
abline(h = 1.96)
####### Fator de ineficiência (IF)
# IF = N / N_eff, onde N_eff = effective Sample Size
# Se IF >> 1, indica uma má mistura da cadeia gerada
N_eff_l = coda::effectiveSize( mcmcchain_l )
IF_l = nrow( burned_l_sim ) / N_eff_l
plot( IF_l )
abline(h = 1)
####### MCMC error
# MCerror = sd( Variavel ) / sqrt( N_eff )
mc_error_l = round( apply( burned_l_sim, MARGIN = 2, FUN = sd) / sqrt( N_eff_h ), 5 )
plot( mc_error_l )








